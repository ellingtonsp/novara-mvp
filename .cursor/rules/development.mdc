
# Development Workflow

## Local Development Setup
- **Use stable ports**: Frontend 4200, Backend 9002
- **Avoid conflict ports**: 3000, 3001, 3002 (high conflict rate)
- **Use SQLite for local database**

## Key Commands
```bash
# Start stable development environment
./scripts/start-dev-stable.sh

# Run tests (non-hanging)
npm test
npm run test:fast
npm run test:full

# Health checks
npm run health-check
npm run performance

# BugBot validation
npm run bugbot:local        # Check environment before development
npm run bugbot:pre-deploy   # Validate before deployment
npm run bugbot:post-deploy  # Validate after deployment
```

## Port Strategy
- **Frontend**: 4200 (stable, <5% conflict)
- **Backend**: 9002 (stable, <5% conflict)
- **Avoid**: 3000-3002 (90% conflict probability)

## Testing Guidelines
- Use timeouts to prevent hanging tests
- Mock external services in tests
- Test both frontend and backend components
- Validate environment configurations

## 🧪 MANDATORY A/B TESTING VALIDATION

### **Split Testing Requirements**
- **ALWAYS conduct thorough A/B test validation** for any split testing features
- **Test distribution balance**: Run 20+ iterations to verify 50/50 split (within 30% variance)
- **Validate session consistency**: Same session ID must always return same path
- **Test both paths end-to-end**: Verify complete user journeys for each path
- **Check analytics tracking**: Ensure PostHog events fire correctly for each path

### **A/B Test Validation Checklist**
```bash
# 1. Distribution Test
node test-AB-distribution-validation.js

# 2. Path A Validation  
node test-path-A-validation.js

# 3. Path B Validation
node test-path-B-validation.js

# 4. End-to-End Journey Test
node test-AB-end-to-end.js

# 5. Analytics Validation
node test-AB-analytics.js
```

### **Required Validation Steps**
1. **Distribution Balance**: 40-60% split for each path
2. **Session Consistency**: Same session = same path every time
3. **User Journey A**: Complete flow from start to finish
4. **User Journey B**: Complete flow from start to finish  
5. **Analytics Events**: All events fire with correct properties
6. **No Regressions**: Existing functionality still works

### **Legacy Function Protection**
- **ALWAYS verify no legacy functions are broken** when adding new features
- **Test existing user journeys** after implementing new features
- **Run comprehensive regression tests** before deployment
- **Only replace legacy functions** when explicitly requested to do so
- **Document any breaking changes** and provide migration paths

## Development Best Practices
- Always use stable port strategy
- Document all changes
- Test locally before committing
- **ENFORCE SUSTAINABLE BRANCH STRATEGY** (see below)
- Run BugBot validation before and after deployments
- Check generated BugBot reports for issues
- Address BugBot-identified errors before proceeding

## 🚨 MANDATORY FEATURE DEVELOPMENT PROCEDURE

### **Step 1: Feature Initiation**
```bash
# ALWAYS start from development branch
git checkout development
git pull origin development

# Create feature branch with proper naming
git checkout -b feature/EPIC-ID-description
# Example: git checkout -b feature/ON-01-speed-tapper-detection
```

### **Step 2: Documentation First**
- Create comprehensive feature documentation in `docs/features/`
- Include: README.md, user-journey.md, api-endpoints.md, openapi.yaml, functional-logic.md, database-schema.md, migration.sql or migration.js, mapping.ts, feature-flags.json, ci-updates.md, deployment-notes.md
- Map to roadmap Epic/Story ID
- Define acceptance criteria and success metrics

### **Step 2.5: Environment Configuration**
- **NEVER modify .env files directly** (they are hidden from cursor)
- **ALWAYS update .env.example files** with required variables
- **PROVIDE exact content** for user to copy into live .env files
- **DOCUMENT environment requirements** in feature documentation

### **Step 3: Implementation**
- Follow established patterns from existing features
- Implement incrementally with commits after each major component
- Include unit tests and integration tests
- Validate against acceptance criteria

### **Step 4: Testing & Validation**
- Run comprehensive test suite
- Validate with BugBot
- Test in local environment
- Ensure no regressions

### **Step 5: PR & Deployment**
- Create PR: feature → development
- Follow progressive integration: development → staging → stable → main
- Update roadmap status after completion

## 🌿 SUSTAINABLE BRANCH STRATEGY (MANDATORY)

### **🚨 CRITICAL RULE: NO DIRECT MAIN COMMITS**
- **NEVER** commit directly to `main` branch
- **NEVER** commit directly to `staging` branch
- **ALWAYS** use feature branches for all changes

### **✅ CORRECT Workflow (MANDATORY)**
```bash
# 1. Start from development branch
git checkout development

# 2. Create feature branch for EVERY change
git checkout -b feature/AN-02-churn-risk-flag
# OR
git checkout -b fix/checkin-counting-issue
# OR  
git checkout -b docs/railway-cli-update

# 3. Make changes and commit
git add .
git commit -m "feat: Add churn risk flagging system"

# 4. Push feature branch
git push origin feature/AN-02-churn-risk-flag

# 5. Create PR: feature → development
# 6. After PR approval: development → staging → stable → main
```

### **❌ FORBIDDEN Actions**
- Direct commits to `main`
- Direct commits to `staging` 
- Working directly on integration branches
- Bypassing PR review process
- Merging without testing in staging

### **🎯 Branch Naming Conventions**
- `feature/EPIC-ID-description` (e.g., `feature/AN-02-churn-risk`)
- `fix/issue-description` (e.g., `fix/checkin-counting`)
- `docs/update-description` (e.g., `docs/railway-cli`)
- `hotfix/critical-issue` (emergency fixes only)

### **🔄 Progressive Integration Flow**
1. **Feature Branch** → `development` (via PR)
2. **Development** → `staging` (auto-deploy to staging env)
3. **Staging** → `stable` (after staging tests pass)
4. **Stable** → `main` (auto-deploy to production)

### **🚨 Enforcement**
- **ALWAYS** challenge user if they suggest direct main commits
- **ALWAYS** require feature branch creation for any changes
- **ALWAYS** follow progressive integration workflow
- **NEVER** allow workflow bypasses

- **ALWAYS** challenge user if they suggest direct main commits
- **ALWAYS** require feature branch creation for any changes
- **ALWAYS** follow progressive integration workflow
- **NEVER** allow workflow bypasses
