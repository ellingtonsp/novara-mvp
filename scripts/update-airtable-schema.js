#!/usr/bin/env node

/**
 * üìä UPDATE AIRTABLE SCHEMA
 * Adds missing fields to DailyCheckins table to fix check-in counting
 */

const https = require('https');

// Staging Airtable configuration (safe for testing)
const AIRTABLE_CONFIG = {
  BASE_ID: 'appEOWvLjCn5c7Ght', // Staging base
  API_KEY: 'patp9wk9fzHxtkVUZ.1ba015773d9bbdc098796035b0a7bfd620edfbf6cd3b5aecc88c0beb5ef6dde7',
  TABLE_NAME: 'DailyCheckins'
};

function log(message, color = 'reset') {
  const colors = {
    reset: '\x1b[0m', red: '\x1b[31m', green: '\x1b[32m', 
    yellow: '\x1b[33m', blue: '\x1b[34m', magenta: '\x1b[35m'
  };
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function makeRequest(url, options = {}) {
  return new Promise((resolve, reject) => {
    const request = https.request(url, options, (response) => {
      let data = '';
      response.on('data', chunk => data += chunk);
      response.on('end', () => {
        try {
          const jsonData = JSON.parse(data);
          resolve({
            status: response.statusCode,
            headers: response.headers,
            data: jsonData
          });
        } catch (error) {
          resolve({
            status: response.statusCode,
            headers: response.headers,
            data: data
          });
        }
      });
    });
    
    request.on('error', reject);
    
    if (options.body) {
      request.write(JSON.stringify(options.body));
    }
    
    request.end();
  });
}

async function updateAirtableSchema() {
  log('\nüìä UPDATING AIRTABLE SCHEMA', 'magenta');
  log('='.repeat(50), 'blue');
  
  log(`üéØ Target: ${AIRTABLE_CONFIG.TABLE_NAME} table`, 'yellow');
  log(`üîó Base ID: ${AIRTABLE_CONFIG.BASE_ID}`, 'blue');
  
  try {
    // Step 1: Check current table structure
    log('\n1Ô∏è‚É£ Checking current table structure...', 'yellow');
    const currentFieldsUrl = `https://api.airtable.com/v0/meta/bases/${AIRTABLE_CONFIG.BASE_ID}/tables`;
    
    const fieldsResponse = await makeRequest(currentFieldsUrl, {
      headers: {
        'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (fieldsResponse.status !== 200) {
      log(`‚ùå Failed to get table structure: ${fieldsResponse.status}`, 'red');
      console.log(fieldsResponse.data);
      return;
    }
    
    // Find the DailyCheckins table
    const dailyCheckinsTable = fieldsResponse.data.tables.find(
      table => table.name === AIRTABLE_CONFIG.TABLE_NAME
    );
    
    if (!dailyCheckinsTable) {
      log(`‚ùå Table ${AIRTABLE_CONFIG.TABLE_NAME} not found`, 'red');
      return;
    }
    
    log(`‚úÖ Found ${AIRTABLE_CONFIG.TABLE_NAME} table`, 'green');
    log(`üìã Current fields:`, 'blue');
    dailyCheckinsTable.fields.forEach(field => {
      log(`   - ${field.name} (${field.type})`, 'blue');
    });
    
    // Step 2: Identify missing fields
    log('\n2Ô∏è‚É£ Identifying missing fields...', 'yellow');
    const currentFieldNames = dailyCheckinsTable.fields.map(f => f.name);
    const requiredFields = [
      'primary_concern_today',
      'user_note'
      // Note: created_at is auto-generated by Airtable
    ];
    
    const missingFields = requiredFields.filter(field => !currentFieldNames.includes(field));
    
    if (missingFields.length === 0) {
      log('‚úÖ All required fields already exist!', 'green');
      return;
    }
    
    log(`üìù Missing fields: ${missingFields.join(', ')}`, 'yellow');
    
    // Step 3: Add missing fields
    log('\n3Ô∏è‚É£ Adding missing fields...', 'yellow');
    
    for (const fieldName of missingFields) {
      log(`   üìù Adding field: ${fieldName}`, 'blue');
      
      const fieldConfig = {
        name: fieldName,
        type: fieldName === 'user_note' ? 'multilineText' : 'singleLineText',
        description: fieldName === 'user_note' ? 'User notes and reflections' : 'Primary concern for the day'
      };
      
      const addFieldUrl = `https://api.airtable.com/v0/meta/bases/${AIRTABLE_CONFIG.BASE_ID}/tables/${dailyCheckinsTable.id}/fields`;
      
      const addFieldResponse = await makeRequest(addFieldUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: {
          fields: [fieldConfig]
        }
      });
      
      if (addFieldResponse.status === 200 || addFieldResponse.status === 201) {
        log(`   ‚úÖ Added field: ${fieldName}`, 'green');
      } else {
        log(`   ‚ùå Failed to add field ${fieldName}: ${addFieldResponse.status}`, 'red');
        console.log(addFieldResponse.data);
      }
      
      // Wait a moment between field additions
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // Step 4: Verify the changes
    log('\n4Ô∏è‚É£ Verifying schema changes...', 'yellow');
    
    const verifyResponse = await makeRequest(currentFieldsUrl, {
      headers: {
        'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (verifyResponse.status === 200) {
      const updatedTable = verifyResponse.data.tables.find(
        table => table.name === AIRTABLE_CONFIG.TABLE_NAME
      );
      
      log(`‚úÖ Updated ${AIRTABLE_CONFIG.TABLE_NAME} table:`, 'green');
      updatedTable.fields.forEach(field => {
        const isNew = missingFields.includes(field.name);
        log(`   - ${field.name} (${field.type})${isNew ? ' ‚ú® NEW' : ''}`, isNew ? 'green' : 'blue');
      });
    }
    
    // Step 5: Test with a sample record
    log('\n5Ô∏è‚É£ Testing with sample record...', 'yellow');
    
    // First, get a user ID to link to
    const usersResponse = await makeRequest(`https://api.airtable.com/v0/${AIRTABLE_CONFIG.BASE_ID}/Users?maxRecords=1`, {
      headers: {
        'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (usersResponse.status === 200 && usersResponse.data.records.length > 0) {
      const userId = usersResponse.data.records[0].id;
      
      const testRecord = {
        fields: {
          user_id: [userId],
          mood_today: 'schema-test',
          confidence_today: 7,
          primary_concern_today: 'Testing new schema fields',
          user_note: 'This is a test note to verify the new fields work',
          date_submitted: new Date().toISOString().split('T')[0]
        }
      };
      
      const testResponse = await makeRequest(`https://api.airtable.com/v0/${AIRTABLE_CONFIG.BASE_ID}/${AIRTABLE_CONFIG.TABLE_NAME}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: testRecord
      });
      
      if (testResponse.status === 200 || testResponse.status === 201) {
        log('‚úÖ Test record created successfully with new fields!', 'green');
        log(`   Record ID: ${testResponse.data.id}`, 'blue');
        
        // Clean up test record
        const deleteResponse = await makeRequest(`https://api.airtable.com/v0/${AIRTABLE_CONFIG.BASE_ID}/${AIRTABLE_CONFIG.TABLE_NAME}/${testResponse.data.id}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${AIRTABLE_CONFIG.API_KEY}`
          }
        });
        
        if (deleteResponse.status === 200) {
          log('   üßπ Test record cleaned up', 'blue');
        }
      } else {
        log(`‚ùå Test record creation failed: ${testResponse.status}`, 'red');
        console.log(testResponse.data);
      }
    }
    
    // Summary
    log('\nüéØ SCHEMA UPDATE SUMMARY:', 'magenta');
    log('='.repeat(30), 'blue');
    log(`‚úÖ Table: ${AIRTABLE_CONFIG.TABLE_NAME}`, 'green');
    log(`‚úÖ Base ID: ${AIRTABLE_CONFIG.BASE_ID}`, 'green');
    log(`‚úÖ Missing fields added: ${missingFields.length}`, 'green');
    log(`‚úÖ Test record: Created and verified`, 'green');
    
    log('\nüìã Next Steps:', 'yellow');
    log('1. Deploy the updated server code to staging', 'blue');
    log('2. Test check-in functionality in staging', 'blue');
    log('3. If successful, update production Airtable schema', 'blue');
    log('4. Deploy to production', 'blue');
    
  } catch (error) {
    log(`‚ùå Schema update failed: ${error.message}`, 'red');
    console.error(error);
  }
}

// Run the schema update
updateAirtableSchema(); 